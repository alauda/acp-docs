---
weight: 10
sourceSHA: 08fa64ae9ae12557bf7ba851b09d7c7def503b03ee30e5693cee1e401147b1e2
---

# Redis BigKey

## Введение в BigKey

В Redis BigKeys потребляют чрезмерные ресурсы памяти, что влияет на производительность и доступность Redis.

Как правило, следующие условия могут привести к тому, что ключ будет считаться BigKey:

- Для ключей строкового типа, если выделенная память превышает 5 МБ.
- Для ключей типа список, если количество элементов превышает 20,000, или если выделенная память превышает 1 МБ.
- Для ключей типа множество, если количество элементов превышает 5,000, или если выделенная память превышает 1 МБ.
- Для ключей типа отсортированное множество, если количество элементов превышает 10,000, или если выделенная память превышает 1 МБ.
- Для ключей типа хэш, если количество полей превышает 1,000, или если выделенная память превышает 1 МБ.

**Примечание**: Эти пороговые значения не являются жесткими правилами и должны оцениваться в зависимости от вашей реальной ситуации для определения того, квалифицируется ли ключ как BigKey.

## Как определить BigKeys в экземпляре Redis?

Используйте следующую команду для выборки и проверки ключей в Redis, определяя те, которые занимают большое количество памяти, вместе с их типами и размерами.

```bash
redis-cli --bigkeys
```

Для получения более подробных методов обнаружения BigKeys, обратитесь к <ExternalSiteLink name="redis" href="trouble_shooting/20-bigkeycheck.mdx" children="Обнаружение и обработка BigKeys" />.

## Как исправить BigKeys в экземпляре Redis?

| Тип BigKey     | Методы исправления                                                                                                                                                                                                                                                                                                                       |
| -------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Строка**     | Рассмотрите возможность разделения BigKey на несколько меньших строк для хранения. Используйте команды `GETRANGE` и `SETRANGE`, чтобы читать и изменять части строки, тем самым разбивая большую строку на несколько меньших строк.                                                                                                                                       |
| **Хэш**        | Разделите BigKey на несколько меньших хэшей. Сначала разбейте множество ключей большого хэша на части, затем разделите множества полей соответствующего хэша каждого ключа, а затем разбейте соответствующее значение каждого поля на части. Таким образом, большой хэш можно разделить на несколько меньших хэшей.                                       |
| **Список**     | Рассмотрите возможность разделения BigKey на несколько меньших списков для хранения. Используйте команды `LRANGE` и `RPUSH`, чтобы читать и изменять части списка, тем самым разбивая большой список на несколько меньших списков.                                                                                                                                                  |
| **Множество**  | Рассмотрите возможность разделения BigKey на несколько меньших множеств для хранения. Используйте команды `SMEMBERS` и `SADD`, чтобы читать и изменять элементы во множестве, тем самым разбивая большое множество на несколько меньших множеств.                                                                                                                         |
| **Отсортированное множество** | Разделите BigKey на несколько меньших отсортированных множеств. Сначала разделите множество ключей большого отсортированного множества, затем разделите элементы соответствующего отсортированного множества каждого ключа. Используйте команды `ZRANGE` и `ZADD`, чтобы читать и изменять элементы в отсортированном множестве, тем самым разбивая большое отсортированное множество на несколько меньших. |
