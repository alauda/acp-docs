---
weight: 20
sourceSHA: 3eca2d2519d8971f8af02614ea7751ce7f257771c96dd8df306453d46ff960f3
---

# Оптимизация использования памяти MySQL

Одним из ключевых показателей для MySQL является уровень использования памяти экземпляра и коэффициент попадания в буферный пул. Высокое использование памяти увеличивает риск ошибок OOM (Недостаток памяти), в то время как низкий коэффициент попадания в буферный пул указывает на то, что многие страницы данных не попадают на закэшированные страницы данных в буферном пуле, что требует считывания данных из хранилища, что увеличивает пропускную способность ввода-вывода и задержку.

## Проверка использования памяти

### Проверка общего использования памяти

```
select * from sys.memory_global_total;
```

**Примечание**: Из-за ограничений в частоте обновления данных, кэшировании и использовании ядра (эта часть не учитывается) этот запрос даёт приблизительное представление об использовании памяти.

### Проверка 20 событий с наибольшим использованием памяти

```
select event_name,CURRENT_NUMBER_OF_BYTES_USED/1024/1024
from performance_schema.memory_summary_global_by_event_name
order by CURRENT_NUMBER_OF_BYTES_USED desc LIMIT 20;
```

### Проверка 20 потоков с наибольшим использованием памяти

```
select thread_id,event_name,CURRENT_NUMBER_OF_BYTES_USED/1024/1024
from performance_schema.memory_summary_by_thread_by_event_name
order by CURRENT_NUMBER_OF_BYTES_USED desc limit 20;
```

### Проверка currently allocated memory

```
select substring_index(event_name,'/',2) as code_area, format_bytes(sum(current_alloc)) as current_alloc
from sys.x$memory_global_by_current_bytes
group by substring_index(event_name,'/',2)
order by sum(current_alloc) DESC;
```

## Рекомендации по оптимизации использования памяти

### Множественные инструкции

MySQL поддерживает использование точки с запятой `;` для разделения нескольких SQL-инструкций, отправляя их в MySQL вместе для последовательной обработки. Однако, некоторые объекты памяти нужно ждать, пока все SQL-инструкции завершат выполнение, прежде чем их можно будет освободить.

Если одновременно отправляется большое количество SQL-инструкций, достигающее нескольких сотен мегабайт, то в процессе выполнения SQL-инструкций распределение и накопительное потребление различных объектов могут быть очень большими, что может привести к исчерпанию памяти в процессе MySQL.

Кроме того, использование нескольких инструкций для отправки SQL может вызвать резкое увеличении сетевого трафика, что можно оценить с помощью мониторинга сетевого трафика и анализа SQL. Таким образом, в бизнес-применениях рекомендуется по возможности избегать методов отправки SQL с несколькими инструкциями.

### Проблемы с буферным пулом

Все страницы данных для таблиц хранятся в буферном пуле. Во время выполнения запроса, если необходимые страницы данных попадают напрямую в буферный пул, физические ввод-вывод не происходят, обеспечивая более высокую эффективность выполнения SQL. Буферный пул управляет страницами данных с помощью алгоритма LRU (Least Recently Used), при этом все "грязные" страницы помещаются в связанный список Flush List.

В системах с большим объемом памяти память InnoDB Buffer Pool обычно является самой большой в памяти экземпляра. Количество экземпляров буферного пула можно увеличить, изменив параметр innodb\_buffer\_pool\_instances, что улучшает производительность параллельной обработки.

Общие проблемы, связанные с буферным пулом, и рекомендации по оптимизации показаны в таблице ниже.

| Описание проблемы                                                  | Причина или рекомендация                                                                                                                                                                                                                                                                                                    |
| ------------------------------------------------------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Недостаточное предварительное прогревание страниц данных, приводящее к высокой задержке запросов** | Обычно возникает в экземплярах после перезапуска, при чтении "холодных" данных или при низких коэффициентах попадания в буферный пул. Рекомендуется либо обновить характеристики экземпляра, либо предварительно прогреть данные.                                                                                                                              |
| **Чрезмерное накопление грязных страниц**                          | Когда слишком много грязных страниц не сбрасывается, фоновые потоки будут инициировать синхронизацию и обновлять грязные страницы, что значительно ухудшает производительность экземпляра. К решениям относятся балансировка записи нагрузки, избежание чрезмерной записи, настройка параметров обновления грязных страниц или обновление характеристик экземпляра. |
| **Полные сканирования таблиц загрязняют буферный пул**            | Полные сканирования таблиц следует избегать, например, не использовать такие инструкции, как `select * from large_table`, чтобы уменьшить загрязнение буферного пула.                                                                                                                                                                     |

### Временные таблицы

При использовании временных таблиц в памяти в MySQL их размер ограничивается параметрами tmp\_table\_size и max\_heap\_table\_size. Временные таблицы, превышающие этот лимит параметров, будут преобразованы в временные таблицы на диске. Если большое количество подключений создает множество временных таблиц в памяти за короткий период, это может привести к резкому увеличению использования памяти.

MySQL 8.0 вводит новый механизм временных таблиц. Этот механизм требует, чтобы общий размер временных таблиц в памяти, выделяемых всеми потоками, должен быть меньше параметра temptable\_max\_ram, который по умолчанию равен 1 ГБ. Когда временные таблицы в памяти превышают этот лимит, они будут преобразованы в временные таблицы на диске.

### Кэш коммуникации кластера

При использовании MGR (MySQL Group Replication) для формирования кластера необходимо также учитывать потребление кэша коммуникации XCom Cache. По умолчанию размер этого кэша составляет 1 ГБ. В условиях хорошего качества сети можно использовать более низкий параметр group\_replication\_message\_cachesize для создания кластера, что снизит использование памяти.

### Прочие

Когда число таблиц в экземпляре особенно велико или когда частота запросов очень высока, кэш таблиц может потреблять большое количество памяти. Рекомендуется избегать создания избыточного количества таблиц в экземпляре или установить параметр table\_open\_cache на подходящий размер.

AHI (Adaptive Hash Index) по умолчанию занимает 1/64 памяти в буферном пуле. Если запрашивается или записывается значительное количество крупных полей, таких как BLOB, память будет динамически выделяться, что увеличивает использование памяти. Отключение AHI может более эффективно и разумно использовать ресурсы памяти сервера, освобождая больше доступной памяти для бизнес-систем, и таким образом улучшая общую производительность. Однако следует отметить, что AHI также способен ускорять определенные запросы, поэтому необходимо найти баланс между преимуществами производительности запросов и оптимизацией памяти при его отключении.

Если наблюдается необычное увеличение использования памяти или исчерпание памяти в экземпляре MySQL, рекомендуется обратиться к [официальной документации MySQL 5.7](https://dev.mysql.com/doc/refman/5.7/en/optimizing-innodb-diskio.html) или [официальной документации MySQL 8.0](https://dev.mysql.com/doc/refman/8.0/en/optimizing-innodb-diskio.html) для выяснения причин увеличения использования памяти.
