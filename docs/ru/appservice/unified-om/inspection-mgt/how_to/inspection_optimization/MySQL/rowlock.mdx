---
weight: 50
sourceSHA: 9cb1573e33cfe32afa3eb86a37e62c34fc18eb8e78a86fc807e66fd7fa421073
---

# Оптимизация блокировок строк MySQL

Эксклюзивные блокировки (X-блокировки) и разделяемые блокировки (S-блокировки) являются концептуальными блокировками уровня строк InnoDB, которые используются для обеспечения последовательности модификаций и удалений одной и той же записи строк, тем самым гарантируя сильную согласованность данных. Они применяются в трех основных сценариях: блокировки записей, блокировки промежутков и блокировки следующего ключа. В ситуациях высокой одновременности требуется правильная конфигурация для избежания чрезмерного количества взаимных блокировок.

## Проверка ожидания блокировок строк

Следующий SQL-запрос можно использовать, чтобы проверить ожидание блокировок строк.

```
show status like 'Innodb_row_lock_%';
```

| Параметр возврата                       | Описание                                              |
| ---------------------------------------- | ----------------------------------------------------- |
| **Innodb\_row\_lock\_current\_waits**  | Число текущих ожиданий блокировок строк              |
| **Innodb\_row\_lock\_time**            | Общее время, затраченное на получение блокировок строк, в миллисекундах   |
| **Innodb\_row\_lock\_time\_avg**       | Среднее время получения блокировок строк, в миллисекундах |
| **Innodb\_row\_lock\_time\_max**       | Максимальное время получения блокировок строк, в миллисекундах |
| **Innodb\_row\_lock\_waits**           | Количество случаев ожидания блокировки строк          |

## Рекомендации по оптимизации проблем с ожиданием блокировок строк

### Высокая одновременность базы данных

Когда MySQL сталкивается с чрезмерным количеством параллельных запросов, возникают ситуации ожидания из-за конкуренции за блокировки строк. Чтобы избежать конфликтов блокировок, рекомендуется оптимизировать горячие обновления в бизнесе и использовать такие техники, как постраничные запросы или сегментированные запросы при обработке больших объемов данных. Эти методы могут предотвратить блокировку слишком большого количества строк данных в одном запросе, что снижает риск конфликтов блокировок и улучшает производительность системы и скорость отклика. Кроме того, параметры `innodb_lock_wait_timeout` и `interactive_timeout` могут быть настроены для установки максимальной продолжительности транзакций, ожидающих получения ресурсов. Это помогает оптимизировать механизм блокировки и улучшить доступность системы.

В случаях, когда взаимные блокировки редки, можно установить `innodb_print_all_deadlocks=ON`, чтобы выводить детальную информацию о каждом случае взаимной блокировки в журнал ошибок, что поможет проанализировать причины взаимных блокировок. Однако, если взаимные блокировки часто происходят в бизнесе, для поддержания журнала ошибок и производительности сервера лучше установить `innodb_print_all_deadlocks` в OFF, выводя только сводную информацию о взаимных блокировках. Если необходимо провести детальный анализ взаимных блокировок, этот параметр можно временно установить в ON, чтобы наблюдать за детальной информацией о взаимных блокировках в течение определенного времени, а затем снова выключить, чтобы минимизировать влияние на производительность сервера.

### Отсутствующие индексы

Чтобы избежать эскалации InnoDB до блокировок таблиц из-за невозможности получить блокировки строк через индексы, рекомендуется как можно чаще использовать индексы для извлечения данных. Кроме того, при добавлении индексов следует проявлять осторожность, чтобы быть как можно более точным, чтобы избежать ненужной блокировки, что может повлиять на производительность других запросов.

### Чрезмерный диапазон блокировки

Чтобы избежать блокировки записей, которые не следует блокировать из-за извлечения диапазона (т.е. блокировок промежутков), рекомендуется минимизировать использование диапазонных запросов. Кроме того, чтобы сократить объем заблокированных ресурсов и время блокировки, следует контролировать размер транзакций. Что касается уровней изоляции транзакций, рекомендуется использовать более низкие уровни изоляции, когда это возможно, чтобы уменьшить затраты, связанные с обработкой изоляции транзакций MySQL.
