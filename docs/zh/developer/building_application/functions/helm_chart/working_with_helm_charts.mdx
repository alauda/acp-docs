---
weight: 40
---

# Working with Helm charts

## 1. Understanding Helm

Helm is a package manager that simplifies the deployment of applications and services on Alauda Container Platform clusters.
Helm uses a packaging format called *charts*. A Helm chart is a collection of files that describe Kubernetes resources.
Creating a chart in a cluster generates a chart running instance called a *release*.
Each time a chart is created, or a release is upgraded or rolled back, an incremental revision is created.

### 1.1. Key features

Helm provides the ability to:

* Search for a large collection of charts in chart repositories
* Modify existing charts
* Create your own charts using Kubernetes resources
* Package applications and share them as charts

### 1.2. Catalog

The Catalog is built on Helm and provides a comprehensive Chart distribution management platform, extending the limitations of the Helm CLI tool. The platform enables developers to more conveniently manage, deploy, and use charts through a user-friendly interface.

#### Terminology Definitions

| Term                | Definition                                                   | Notes                |
| ------------------- | ------------------------------------------------------------ | -------------------- |
| Application Catalog | A one-stop management platform for Helm Charts               |                      |
| Helm Charts         | An application packaging format                              |                      |
| HelmRequest         | CRD. Defines the configuration needed to deploy a Helm Chart | Template Application |
| ChartRepo           | CRD. Corresponds to a Helm charts repository                 | Template Repository  |
| Chart               | CRD. Corresponds to Helm Charts                              | Template             |

### 1.3 Understanding HelmRequest

In Alauda Container Platform, Helm deployments are primarily managed through a custom resource called **HelmRequest**. This approach extends standard Helm functionality and integrates it seamlessly into the Kubernetes native resource model.

##### Differences Between HelmRequest and Helm

Standard Helm uses CLI commands to manage releases, while Alauda Container Platform uses HelmRequest resources to define, deploy, and manage Helm charts. Key differences include:

1. **Declarative vs Imperative**: HelmRequest provides a declarative approach to Helm deployments, while traditional Helm CLI is imperative.
2. **Kubernetes Native**: HelmRequest is a custom resource directly integrated with the Kubernetes API.
3. **Continuous Reconciliation**: Captain continuously monitors and reconciles HelmRequest resources with their desired state.
4. **Multi-cluster Support**: HelmRequest supports deployments across multiple clusters through the platform.
5. **Platform Feature Integration**: HelmRequest can be integrated with other platform features, such as Application resources.

##### HelmRequest and Application Integration

HelmRequest and Application resources have conceptual similarities, and users may want to view them uniformly. The platform provides a mechanism to synchronize HelmRequest as Application resources.

Users can mark a HelmRequest to be deployed as an Application by adding the following annotation:

```
alauda.io/create-app: "true"
```

When this feature is enabled, the platform UI displays additional fields and links to the corresponding Application page.

##### Deployment Workflow

![HelmRequest Workflow图]// 待补充

The workflow for deploying charts via HelmRequest includes:

1. **User** creates or updates a HelmRequest resource
2. **HelmRequest** contains chart references and values to apply
3. **Captain** processes the HelmRequest and creates a Helm Release
4. **Release** contains the deployed resources
5. **Charon** monitors HelmRequests with application annotations and synchronizes them to Applications
6. **Application** provides a unified view of deployed resources

##### Component Definitions

* **HelmRequest**: Custom resource definition that describes the desired Helm chart deployment
* **Captain**: Controller that processes HelmRequest resources and manages Helm releases (source code available at https://github.com/alauda/captain)
* **Release**: Deployed instance of a Helm chart
* **Charon**: Component that monitors HelmRequests and creates corresponding Application resources
* **Application**: Unified representation of deployed resources, providing additional management capabilities
* **Archon-api**: Component responsible for specific advanced API functions within the platform

## 通过 cli 去部署 helm chart 为原生应用

### 1. 准备工作流程

准备chart → 打包chart → 获取API令牌 → 创建模板仓库 → 上传chart → 上传相关镜像 → 部署应用 → 更新应用 → 卸载应用 → 删除模板仓库

### 2. 准备Chart

Helm使用的包格式称为chart。chart是描述Kubernetes相关资源的文件集合。单个chart可以用来部署简单的pod或复杂的应用栈。

参考官方文档：[Helm Charts Documentation](https://helm.sh/zh/docs/topics/charts/)

Chart目录结构示例：

```
nginx/
├── Chart.lock
├── Chart.yaml
├── README.md
├── charts/
│   └── common/
│       ├── Chart.yaml
│       ├── README.md
│       ├── templates/
│       │   ├── _affinities.tpl
│       │   ├── _capabilities.tpl
│       │   ├── _errors.tpl
│       │   ├── _images.tpl
│       │   ├── _ingress.tpl
│       │   ├── _labels.tpl
│       │   ├── _names.tpl
│       │   ├── _secrets.tpl
│       │   ├── _storage.tpl
│       │   ├── _tplvalues.tpl
│       │   ├── _utils.tpl
│       │   ├── _warnings.tpl
│       │   └── validations/
│       │       ├── _cassandra.tpl
│       │       ├── _mariadb.tpl
│       │       ├── _mongodb.tpl
│       │       ├── _postgresql.tpl
│       │       ├── _redis.tpl
│       │       └── _validations.tpl
│       └── values.yaml
├── ci/
│   ├── ct-values.yaml
│   └── values-with-ingress-metrics-and-serverblock.yaml
├── templates/
│   ├── NOTES.txt
│   ├── _helpers.tpl
│   ├── deployment.yaml
│   ├── extra-list.yaml
│   ├── health-ingress.yaml
│   ├── hpa.yaml
│   ├── ingress.yaml
│   ├── ldap-daemon-secrets.yaml
│   ├── pdb.yaml
│   ├── server-block-configmap.yaml
│   ├── serviceaccount.yaml
│   ├── servicemonitor.yaml
│   ├── svc.yaml
│   └── tls-secrets.yaml
├── values.descriptor.yaml
├── values.schema.json
└── values.yaml
```

关键文件说明：

- `values.descriptor.yaml` (可选): 与ACP UI结合展示友好表单
- `values.schema.json` (可选): 校验values.yaml内容并渲染简单UI
- `values.yaml` (必需): 定义chart部署参数

### 3. 打包Chart

使用`helm package`命令打包chart:

```bash
helm package nginx
# 输出: Successfully packaged chart and saved it to: /charts/nginx-8.8.0.tgz
```

### 4. 获取API令牌

1. 在 **Alauda Container Platform** 平台点击右上角头像 => **Profile**
2. 点击 **Add Api Token**
3. 输入相应的 Description & Remaining Validity
4. 保存回显的令牌信息(仅显示一次)

### 5. 创建模板仓库

通过API创建本地类型模板仓库:

```bash
curl -k --request POST \
--url https://$ACP_DOMAIN/catalog/v1/chartrepos \
--header 'Authorization:Bearer $API_TOKEN' \
--header 'Content-Type: application/json' \
--data '{
  "apiVersion": "v1",
  "kind": "ChartRepoCreate",
  "metadata": {
    "name": "test",
    "namespace": "cpaas-system"
  },
  "spec": {
    "chartRepo": {
      "apiVersion": "app.alauda.io/v1beta1",
      "kind": "ChartRepo",
      "metadata": {
        "name": "test",
        "namespace": "cpaas-system",
        "labels": {
          "project.cpaas.io/catalog": "true"
        }
      },
      "spec": {
        "type": "Local",
        "url": null,
        "source": null
      }
    }
  }
}'
```

### 6. 上传Chart

上传打包好的chart到模板仓库:

```bash
curl -k --request POST \
--url https://$ACP_DOMAIN/catalog/v1/chartrepos/cpaas-system/test/charts \
--header 'Authorization:Bearer $API_TOKEN' \
--data-binary @"/root/charts/nginx-8.8.0.tgz"
```

### 7. 上传相关镜像

1. 拉取镜像: `docker pull nginx`
2. 保存为tar包: `docker save nginx > nginx.latest.tar`
3. 加载并推送到私有仓库:

```bash
docker load -i nginx.latest.tar
docker tag nginx:latest 192.168.80.8:30050/nginx:latest
docker push 192.168.80.8:30050/nginx:latest
```

### 8. 部署应用

通过API创建Application资源:

```bash
curl -k --request POST \
--url https://$ACP_DOMAIN/acp/v1/kubernetes/$CLUSTER_NAME/namespaces/$NAMESPACE/applications \
--header 'Authorization:Bearer $API_TOKEN' \
--header 'Content-Type: application/json' \
--data '{
  "apiVersion": "app.k8s.io/v1beta1",
  "kind": "Application",
  "metadata": {
    "name": "test",
    "namespace": "catalog-ns",
    "annotations": {
      "app.cpaas.io/chart.source": "test/nginx",
      "app.cpaas.io/chart.version": "8.8.0",
      "app.cpaas.io/chart.values": "{\"image\":{\"pullPolicy\":\"IfNotPresent\"}}"
    },
    "labels": {
      "sync-from-helmrequest": "true"
    }
  }
}'
```

### 9. 更新应用

使用PATCH请求更新应用:

```bash
curl -k --request PATCH \
--url https://$ACP_DOMAIN/acp/v1/kubernetes/$CLUSTER_NAME/namespaces/$NAMESPACE/applications/test \
--header 'Authorization:Bearer $API_TOKEN' \
--header 'Content-Type: application/merge-patch+json' \
--data '{
  "apiVersion": "app.k8s.io/v1beta1",
  "kind": "Application",
  "metadata": {
    "annotations": {
      "app.cpaas.io/chart.values": "{\"image\":{\"pullPolicy\":\"Always\"}}"
    }
  }
}'
```

### 10. 卸载应用

删除Application资源:

```bash
curl -k --request DELETE \
--url https://$ACP_DOMAIN/acp/v1/kubernetes/$CLUSTER_NAME/namespaces/$NAMESPACE/applications/test \
--header 'Authorization:Bearer $API_TOKEN'
```

### 11. 删除模板仓库

```bash
curl -k --request DELETE \
--url https://$ACP_DOMAIN/apis/app.alauda.io/v1beta1/namespaces/cpaas-system/chartrepos/test \
--header 'Authorization:Bearer $API_TOKEN'
```


