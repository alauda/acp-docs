---
sourceSHA: 3eca2d2519d8971f8af02614ea7751ce7f257771c96dd8df306453d46ff960f3
---

# MySQL 内存使用优化

MySQL 的一个关键指标是实例内存使用率和缓冲池命中率。高内存使用率增加了 OOM（内存不足）错误的风险，而低缓冲池命中率则表明许多数据页未命中缓冲池中的缓存数据页，需要从存储中读取数据，从而增加了 IO 吞吐量和延迟。

## 检查内存使用情况

### 检查总内存使用

```
select * from sys.memory_global_total;
```

**注意**：由于数据更新频率、缓存和内核使用的限制（此部分不计入），该语句提供了内存使用情况的大致指示。

### 检查内存使用前 20 的事件

```
select event_name,CURRENT_NUMBER_OF_BYTES_USED/1024/1024
from performance_schema.memory_summary_global_by_event_name
order by CURRENT_NUMBER_OF_BYTES_USED desc LIMIT 20;
```

### 检查内存使用前 20 的线程

```
select thread_id,event_name,CURRENT_NUMBER_OF_BYTES_USED/1024/1024
from performance_schema.memory_summary_by_thread_by_event_name
order by CURRENT_NUMBER_OF_BYTES_USED desc limit 20;
```

### 检查当前分配的内存

```
select substring_index(event_name,'/',2) as code_area, format_bytes(sum(current_alloc)) as current_alloc
from sys.x$memory_global_by_current_bytes
group by substring_index(event_name,'/',2)
order by sum(current_alloc) DESC;
```

## 内存使用优化建议

### 多个语句

MySQL 支持使用分号 `;` 分隔多个 SQL 语句，将其一起发送到 MySQL 进行逐个处理。然而，有些内存需要等待所有 SQL 语句执行完毕后才能释放。

如果同时发送大量 SQL 语句，例如达到数百兆字节，则在 SQL 语句执行过程中，各种对象的分配和累积消耗可能非常大，可能导致 MySQL 进程内存耗尽。

此外，使用多个语句发送 SQL 可能会导致网络流量突然增加，这可以通过网络流量监控和 SQL 监控进行评估。因此，在业务实现中，建议尽量避免使用多语句的 SQL 发送方式。

### 缓冲池问题

所有表的数据页都存储在缓冲池中。在查询执行期间，如果所需数据页直接命中缓冲池，则不会发生物理 I/O，从而提高了 SQL 执行效率。缓冲池使用 LRU（最近最少使用）算法管理数据页，所有脏页放置在 Flush List 链表中。

在内存较大的系统中，InnoDB 缓冲池内存通常是实例内存中最大的。可以通过修改 innodb\_buffer\_pool\_instances 参数来增加缓冲池实例的数量，从而提高并发性能。

与缓冲池相关的常见问题和优化建议如下表所示。

| 问题描述                                                       | 原因或建议                                                                                                                                                                                                                                                                                                           |
| ------------------------------------------------------------ | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **数据页预热不足导致查询延迟高**                             | 通常发生在重启后的实例、冷数据读取或低缓冲池命中率的情况下。建议升级实例规格或提前进行数据预热。                                                                                                                                                                                                                       |
| **脏页积累过多**                                             | 当脏页未被刷新过多时，后台线程会触发同步并刷新脏页，严重降低实例性能。解决方案包括平衡写入负荷，避免过高的写入吞吐率，调整刷新脏页参数，或升级实例规格。                                                                                                                                                |
| **全表扫描污染缓冲池**                                      | 应避免全表扫描，例如避免使用 `select * from large_table` 这样的语句，以减少对缓冲池的污染。                                                                                                                                                                                                                       |

### 临时表

在 MySQL 中使用内存临时表时，其大小受 tmp\_table\_size 和 max\_heap\_table\_size 参数的限制。超出该参数限制的临时表将转换为磁盘临时表。如果大量连接在短时间内创建许多内存临时表，可能会导致内存使用急剧增加。

MySQL 8.0 引入了一种新的临时表引擎。该引擎要求所有线程分配的内存临时表总大小必须小于参数 temptable\_max\_ram，默认值为 1GB。当内存临时表超过该限制时，它们将被转换为磁盘临时表。

### 集群通信缓存

使用 MGR（MySQL Group Replication）形成集群时，还必须考虑 XCom Cache 通信缓存的消耗。默认情况下，该缓存大小为 1GB。在网络质量良好的环境中，可以通过使用较小的 group\_replication\_message\_cachesize 参数创建集群，从而减少内存使用。

### 其他

当实例中的表数量特别多或查询频率非常高时，Table Cache 可能会消耗大量内存。建议避免在实例中创建过多表，或将 table\_open\_cache 参数设置为适当的大小。

AHI（自适应哈希索引）默认占用缓冲池内存的 1/64。如果查询或写入了大量大字段（例如 BLOB），则内存将动态分配，从而增加内存使用。禁用 AHI 可以更有效合理地利用服务器的内存资源，腾出更多可用内存供业务系统使用，从而提高整体性能。然而，需注意 AHI 也具有加速特定查询的能力，因此在禁用时必须在查询性能提升和内存优化之间取得平衡。

如果 MySQL 实例内存使用异常增加或内存耗尽，建议参考 [MySQL 5.7 官方文档](https://dev.mysql.com/doc/refman/5.7/en/optimizing-innodb-diskio.html) 或 [MySQL 8.0 官方文档](https://dev.mysql.com/doc/refman/8.0/en/optimizing-innodb-diskio.html) 来调查内存使用增加的原因。
