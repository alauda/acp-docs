---
sourceSHA: 9cb1573e33cfe32afa3eb86a37e62c34fc18eb8e78a86fc807e66fd7fa421073
---

# MySQL 行锁优化

排他锁（X 锁）和共享锁（S 锁）是 InnoDB 的行级概念锁，用于确保对同一行记录的修改和删除操作的序列化，从而保证数据的一致性。它们主要应用于三种场景：记录锁、间隙锁和下一个键锁。在高并发情境下，需要进行适当的配置以避免过多的死锁。

## 检查行锁等待情况

以下 SQL 语句可用于检查行锁等待情况。

```
show status like 'Innodb_row_lock_%';
```

| 返回参数                             | 描述                                                    |
| ---------------------------------- | ----------------------------------------------------- |
| **Innodb\_row\_lock\_current\_waits** | 当前行锁等待的数量                                      |
| **Innodb\_row\_lock\_time**          | 获取行锁所需的总时间，以毫秒为单位                      |
| **Innodb\_row\_lock\_time\_avg**     | 获取行锁的平均时间，以毫秒为单位                        |
| **Innodb\_row\_lock\_time\_max**     | 获取行锁的最长时间，以毫秒为单位                        |
| **Innodb\_row\_lock\_waits**         | 行锁等待发生的次数                                      |

## 优化行锁等待问题的建议

### 数据库高并发

当 MySQL 遇到过多的并发请求时，由于行锁争用而导致的等待情况会出现。为了避免锁冲突，建议在业务中优化热点更新，并在处理大量数据时采用分页查询或分段查询等技术。这些方法可以防止在单个查询中锁定过多的数据行，从而降低锁定冲突的风险，提高系统性能和响应速度。此外，可以调整 `innodb_lock_wait_timeout` 和 `interactive_timeout` 参数，设置事务等待资源的最长时间。这有助于优化锁机制，提高系统可用性。

在死锁不常见的情况下，可以设置 `innodb_print_all_deadlocks=ON`，以在错误日志中打印每个死锁发生的详细信息，帮助分析死锁原因。然而，如果业务中死锁较为常见，为了维护错误日志和服务器性能，最好将 `innodb_print_all_deadlocks` 设置为 OFF，仅输出死锁的汇总信息。如果需要详细的死锁分析，可以临时将该参数设置为 ON，以观察一段时间内的详细死锁信息，然后再关闭，以尽量减少对服务器性能的影响。

### 缺失索引

为了避免 InnoDB 因无法通过索引获取行锁而升级到表锁，建议尽可能使用索引进行数据检索。此外，在添加索引时，应尽量精确，以避免不必要的锁定，从而影响其他查询的性能。

### 锁定范围过大

为了避免因范围检索（即间隙锁）而锁定不应锁定的记录，建议尽量减少范围查询的使用。此外，为了减少锁定资源和锁定时间，应控制事务的大小。在事务隔离级别方面，建议在可行的情况下使用较低的隔离级别，以降低与 MySQL 事务隔离处理相关的开销。
