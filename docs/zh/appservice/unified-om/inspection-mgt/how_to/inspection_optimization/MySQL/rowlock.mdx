---
weight: 50
---

# MySQL 行锁优化

排他锁（X锁）和共享锁（S锁）是 InnoDB 行级概念锁，用于确保对同一行记录的修改和删除的串行性，从而保证数据的强一致性。它们分别应用于记录锁、间隙锁和临键锁三种情况。在高并发的情况下，需要合理配置以避免出现过多的死锁。

## 查看行锁等待

通过以下 SQL 语句查看行锁等待。

```
show status like 'Innodb_row_lock_%';
```

|返回参数|说明|
|---|---|
|**Innodb_row_lock_current_waits**|当前正在等待获取行锁的数量|
|**Innodb_row_lock_time**|获取行锁所花费的总时间，单位：毫秒|
|**Innodb_row_lock_time_avg**|平均获取行锁的时间，单位：毫秒|
|**Innodb_row_lock_time_max**|获取行锁的最长时间，单位：毫秒|
|**Innodb_row_lock_waits**|获取行锁等待的次数|

## 行锁等待问题优化建议

### 数据库并发量过高

当MySQL遇到并发请求过多时，由于争夺行锁而出现等待情况。为了避免锁冲突，可尽量优化业务的热点更新，并在处理大批量数据时使用分页查询、分段查询等技术。这些方法可以避免一次查询锁定过多的数据行，减少锁定冲突的风险，提高系统的性能和响应速度。也可以调整innodb_lock_wait_timeout和interactive_timeout参数，以设置事务等待获取资源的最长时间。这有助于优化锁定机制并提高系统的可用性。

在死锁不频繁的情况下，可以通过设置 innodb_print_all_deadlocks=ON 打印发生的每一个死锁的完整信息到错误日志，以帮助分析死锁发生的原因。但是，如果业务中死锁比较普遍，为了 Error log 的可维护性和服务器性能，最好将 innodb_print_all_deadlocks 设置为 OFF，仅输出死锁概要信息。如果需要进行详细死锁分析，则可以暂时将该参数置为 ON，观察一段时间内的死锁详细信息，然后再关闭，最大程度地减少对服务器性能的影响。

### 索引缺失

为避免InnoDB因为无法通过索引加行锁而升级为表锁，建议尽可能使用索引来完成数据检索。此外，在添加索引时，需要尽量准确，避免造成不必要的锁定，从而影响其他查询的性能。

### 锁定范围过大

为避免因为范围检索（即间隙锁）而对不该锁定的记录进行锁定，建议尽量减少使用范围检索。此外，为减少锁定资源量和锁定时间，需要控制事务的大小。在事务隔离级别方面，建议尽可能使用较低级别的隔离级别，以减少 MySQL 在处理事务隔离时所带来的成本。