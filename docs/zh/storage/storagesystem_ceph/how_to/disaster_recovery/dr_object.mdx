---
weight: 66
---

# 对象存储数据容灾

Ceph RGW 的 Multi-Site 功能是一种跨集群的异步数据复制机制，用于在不同地理位置的 Ceph 集群之间实现对象存储数据同步，提供高可用性（HA）​和灾难恢复（DR）​能力。

## 名词解释

| 名词               | 解释                    |
|:------------------|:------------------------|
|**Primary 集群** | 主集群，当前运行业务的集群。   |
|**Secondary 集群** | 次集群，用于备份的集群。     |
|**Realm、ZoneGroup、Zone**|<ul><li>Realm 是 Ceph 对象存储中的最高级别的逻辑分组。它代表一个完整的对象存储命名空间，通常用于多站点复制和同步，一个 Realm 可以跨不同的地理位置或数据中心进行数据复制和同步。</li><li>ZoneGroup 是 Realm 内的一个逻辑分组，包含多个 Zone，ZoneGroup 可以跨多个 Zone 进行数据同步和复制，通常用于在同一地理区域内的不同站点之间共享数据。</li><li>Zone 是 ZoneGroup 内的一个逻辑分组，是实际存储数据的地方，负责管理和存储对象。每个 Zone 可以有自己的数据和元数据池配置。</li></ul>|

## 前提条件

- 请提前准备两个可用于部署 Rook-Ceph 的集群，即 Primary 集群和 Secondary 集群，且集群间网络互通。
- 两个集群使用的平台版本（v3.12 及以上版本）必须保持一致。
- 请确保 Primary 集群和 Secondary 集群均未部署 Ceph 对象存储。
- 请提前参考 [创建存储服务](../../installation/create_service_stand.mdx) 文档，并按照表单页面向导部署 Operator 和创建集群。在成功部署 Operator、创建集群后，**请勿继续按照向导创建对象存储池**，接下来需要使用 CLI 工具配置，配置完成后向导页面会自动退出。


## 操作步骤

提供一个 ZoneGroup 下两个 Zone 进行同步的方案。

<Steps>

  ### 在 Primary 集群中创建对象存储
    该步骤会创建 Realm、ZoneGroup、Primary Zone 以及 Primary Zone 的网关资源
    
    在 Primary 集群的 Control 节点上执行下述命令：

    <Tabs>
    <Tab label="命令">
    ```yaml
    cat << EOF | kubectl apply -f -
    ---
    apiVersion: ceph.rook.io/v1
    kind: CephObjectRealm
    metadata:
      name: <realm-name>
      namespace: rook-ceph
      
    ---
    apiVersion: ceph.rook.io/v1
    kind: CephObjectZoneGroup
    metadata:
      name: <zonegroup-name>
      namespace: rook-ceph
    spec:
      realm: <realm-name>

    ---
    apiVersion: ceph.rook.io/v1
    kind: CephObjectZone
    metadata:
      name: <primary-zone-name>
      namespace: rook-ceph
    spec:
      zoneGroup: <zonegroup-name>
      metadataPool:
        failureDomain: host
        replicated:
          size: 3
          requireSafeReplicaSize: true
      dataPool:
        failureDomain: host
        replicated:
          size: 3
          requireSafeReplicaSize: true
        parameters:
          compression_mode: none
      preservePoolsOnDelete: false
    
    ---
    cat << EOF | kubectl apply -f -
    apiVersion: ceph.rook.io/v1
    kind: CephObjectStore
    metadata:
      name: <object-store-name>
      namespace: rook-ceph
    spec:
      gateway:
        port: 7480
        instances: 2
      zone:
        name: <zone-name>    
    EOF
    ```
    </Tab>
    <Tab label="回显">
    ```
    cephobjectrealm.ceph.rook.io/<realm-name> created
    cephobjectzonegroup.ceph.rook.io/<zonegroup-name> created
    cephobjectzone.ceph.rook.io/<zone-name> created
    cephobjectstore.ceph.rook.io/<object-store-name> created
    ```
    </Tab>
    </Tabs>

    **参数说明**：
    - <a id="realm"></a>`<realm-name>`：Realm 名称。
    - <a id="zone-group"></a>`<zonegroup-name>`： ZoneGroup 名称。
    - <a id="primary-zone"></a>`<primary-zone-name>`：Primary Zone 名称。
    - <a id="gateway"></a>`<object-store-name>`：网关名称。

  ### 为 Primary Zone 配置外部访问
    1. <a id="uid"></a>获取 ObjectStore 的 UID

    ```bash
    kubectl -n rook-ceph get cephobjectstore <object-store-name> -o jsonpath='{.metadata.uid}'
    ```
    **参数说明**
    - `<object-store-name>`：[步骤 1](#gateway) 中网关名称。

    2. 创建外部访问的 Service

    ```yaml
    cat << EOF | kubectl apply -f -
    apiVersion: v1
    kind: Service
    metadata:
      name: rook-ceph-rgw-<object-store-name>-external
      namespace: rook-ceph
      labels:
        app: rook-ceph-rgw
        rook_cluster: rook-ceph
        rook_object_store: <object-store-name>
      ownerReferences:
        - apiVersion: ceph.rook.io/v1
          kind: CephObjectStore
          name: <object-store-name>
          uid: <object-store-uid>
    spec:
      ports:
        - name: rgw
          port: 7480
          targetPort: 7480
          protocol: TCP
      selector:
        app: rook-ceph-rgw
        rook_cluster: rook-ceph
        rook_object_store: <object-store-name>
      sessionAffinity: None
      type: NodePort
    EOF
    ```
    **参数说明**：
    - `<object-store-name>`：[此处](#gateway) 配置的网关名称。
    - `<object-store-uid>`：[此处](#uid) 获取的 UID。 

    3. 执行下述命令，为 CephObjectZone 添加外部访问地址。

    ```bash
    kubectl -n rook-ceph patch cephobjectzone <primary-zone-name> --type merge -p '{"spec":{"customEndpoints":["<external-endpoint>"]}}'
    ```
    **参数说明**：
    - **zone-name**：使用 [此处](#primary-zone) 中配置的 Primary Zone 名称。
    - **external-endpoint**：在 Primary 集群通过[获取的外部地址](#address) 获取。


  ### <a id="aksk"></a>获取 `access-key` 及 `secret-key`。使用 [步骤 1](#zone) 中配置的 Realm 名称进行替换。

    ```bash
    kubectl -n rook-ceph get secrets <realm-name>-keys -o yaml | grep access-key
    kubectl -n rook-ceph get secrets <realm-name>-keys -o yaml | grep secret-key
    ```
    **参数说**：
    - `<realm-name>`：[此处](#realm) 配置的 Realm 名称。

  ### 在 Secondary 集群中部署对象存储

    主要是创建 Secondary Zone，以及配置如何从 Reaml pull 信息

    在 Secondary 集群的 Master 节点上执行下述命令：

    ```yaml
    cat << EOF | kubectl apply -f -
    apiVersion: v1
    kind: Secret
    metadata:
      name: <realm-name>-keys
      namespace: rook-ceph
    data:
      access-key: <access-key>
      secret-key: <secret-key>
    
    ---
    apiVersion: ceph.rook.io/v1
    kind: CephObjectRealm
    metadata:
      name: <realm-name>
      namespace: rook-ceph
    spec:
      pull:
        endpoint: <realm-endpoint>
    
    ---
    apiVersion: ceph.rook.io/v1
    kind: CephObjectZoneGroup
    metadata:
      name: <zone-group-name>
      namespace: rook-ceph
    spec:
      realm: <realm-name>
      
    ---
    apiVersion: ceph.rook.io/v1
    kind: CephObjectZone
    metadata:
      name: <new-zone-name>
      namespace: rook-ceph
    spec:
      zoneGroup: <zone-group-name>
      metadataPool:
        failureDomain: host
        replicated:
          size: 3
          requireSafeReplicaSize: true
      dataPool:
        failureDomain: host
        replicated:
          size: 3
          requireSafeReplicaSize: true
      preservePoolsOnDelete: false

    ---
    apiVersion: ceph.rook.io/v1
    kind: CephObjectStore
    metadata:
      name: <secondary-object-store-name>
      namespace: rook-ceph
    spec:
      gateway:
        port: 7480
        instances: 2
      zone:
        name: <secondary-zone-name>
    EOF
    ```

    **参数说明**：
    - `<access-key>`：[此处](#aksk) 获取的 AK
    - `<secret-key>`：[此处](#aksk) 获取的 SK
    - `<realm-endpoint>`：在平台中切换至主集群 [获取外部地址](#address)。
    - `<realm-name>`：[Realm](#realm)
    - `<zone-group-name>`：[ZoneGroup](#zone-group)
    - `<secondary-zone-name>`：secondary zone 名称。
    - `<secondary-object-store-name>`：secndary 网关名称。

  ### 为 Secondary Zone 配置外部访问
    1. <a id="uids"></a>获取 Secondary 网关的 UID。其中，需使用 [步骤 5](#objss) 中 ObjectStore 的名称替换下述命令中的 \<object-store-name>。
    ```
    kubectl -n rook-ceph get cephobjectstore <secondary-object-store-name> -o jsonpath='{.metadata.uid}'
    ```
    **参数说明**：
    - `<secondary-object-store-name>`：Secondary 网关名称。

    2. 创建外部访问 Service
    ```yaml
    cat << EOF | kubectl apply -f -
    apiVersion: v1
    kind: Service
    metadata:
      name: rook-ceph-rgw-<object-store-name>-external # 使用步骤 5 中配置的 ObjectStore 名称替换 <object-store-name>
      namespace: rook-ceph
      labels:
        app: rook-ceph-rgw
        rook_cluster: rook-ceph
        rook_object_store: <object-store-name> # 使用步骤 5 中配置的 ObjectStore 名称替换 <object-store-name>
      ownerReferences:
        - apiVersion: ceph.rook.io/v1
          kind: CephObjectStore
          name: <object-store-name> # 使用步骤 5 中配置的 ObjectStore 名称替换 <object-store-name>
          uid: <object-store-uid> # 使用步骤 6 中获取的 UID 替换 <object-store-uid>
    spec:
      ports:
        - name: rgw
          port: 7480
          targetPort: 7480
          protocol: TCP
      selector:
        app: rook-ceph-rgw
        rook_cluster: rook-ceph
        rook_object_store: <object-store-name> # 使用步骤 5 中配置的 ObjectStore 名称替换 <object-store-name>
      sessionAffinity: None
      type: NodePort
    EOF
    ```
    **参数说明**：
    - `<secondary-object-store-name>`：Secondary 网关名称。
    - `<secondary-object-store-uid>`：Secondary 网关 UID。

    
    3. 为 Secondary Zone 添加外部访问地址

    ```
    kubectl -n rook-ceph patch cephobjectzone <secondary-zone-name> --type merge -p '{"spec":{"customEndpoints":["<external-endpoint>"]}}'
    ```
    参数说明：
    - `<secondary-zone-name>`：Secondary Zone 名称。
    - `<secondary-zone-external-endpoint>`：Secondary Zone [外部访问地址](#address)。

</Steps>

## 故障切换

当 Primary 集群故障时，需要把 Secondary Zone 设置为 Primary Zone。切换后可以使用 Secondary 的网关继续提供对象存储服务。

### 操作步骤

  在 Secondary 集群的 rook-ceph-tools pod 中执行
  ```bash
  radosgw-admin zone modify --rgw-realm=<realm-name> --rgw-zonegroup=<zone-group-name> --rgw-zone=<secondary-zone-name> --master
  ```
  **参数说明**
  - `<realm-name>`：Realm 名称进行替换。
  - `<zone-group-name>`：Zone Group 名称。
  - `<secondary-zone-name>`：Secondary Zone 名称。

## 相关操作

### <a id="address"></a>获取外部地址

1. 进入 **平台管理**。

2. 单击页面最上方 **集群**，切换至对应集群。
2. 在左侧导航栏中，单击 **存储管理** > **分布式存储**。
3. 单击 **存储池** 区域，类型为 **对象存储** 的存储池右侧 Action 列表 > **查看地址**。
4. 复制并保存 **外部地址**。