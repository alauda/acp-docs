---
weight: 11
---

# Configure GatewayAPI Gateway

## Prerequisites
Install `envoy-gateway-operator` and create a `EnvoyGatewayCtl`, please follow the instructions in the [installation guide](../how_to/install_envoy_gateway_via_envoy_gateway_operator.mdx).

## Configuration Via Web Console
1. Navigate to `Alauda Container Platform -> Networking -> Gateways`
2. Click on `Create Gateway` button
3. In `Create Gateway` page select `envoy-gateway-operator-cpaas-default` under GatewayClass, it will display the following configuration options:

   | Field | Description | YAML Path|
   |-------|-------------|----------|
   | Name  | name |gateway: `.metadata.name`<br/>envoygateway: `.metadata.name` |
   | GatewayClass  | which GatewayClass it uses | gateway: `.spec.gatewayClassName`|
   | Service Type  | [service type](#service_type) | envoygateway: `.spec.provider.kubernetes.envoyService.type`|
   | Service Annotation  | service annotation | envoygateway: `.spec.provider.kubernetes.envoyService.annotations` |
   | Resource Limits  | deployment resource limits | envoygateway: `.spec.provider.kubernetes.envoyDeployment.container.resources`| 
   | Replicas  | deployment replicas |envoygateway: `.spec.provider.kubernetes.envoyService.replicas` | 
   | Node Labels | deployment node labels | envoygateway: `.spec.provider.kubernetes.envoyService.nodeSelector` | 
   | Listener | [listener](#listener) | gateway: `.spec.listeners` |
   
   :::warning
   The Web Console form only supports GatewayClasses created by `EnvoyGatewayCtl`. For other GatewayClasses, use the YAML editor.
   :::
   
   :::note
   When using an `EnvoyGatewayCtl`-created `GatewayClass`, the Web Console automatically creates a [companion envoyproxy resource](#companion_envoyproxy) matching the Gateway's name and namespace.
   :::
   


## Configuration Via YAML
### Configuration
```yaml
apiVersion: gateway.networking.k8s.io/v1
kind: Gateway
metadata:
  name: demo
  namespace: demo
spec:
  infrastructure: # [!code callout]
    parametersRef:
      group: gateway.envoyproxy.io
      kind: EnvoyProxy
      name: demo
  gatewayClassName: envoy-gateway-operator-cpaas-default # [!code callout]
  listeners: # [!code callout]
  - name: http
    port: 80
    hostname: a.com  # [!code callout]
    protocol: HTTP  # [!code callout]
    allowedRoutes:
      namespaces:
        from: Same # [!code callout]
  - name: https
    port: 443
    hostname: a.com
    protocol: HTTPS
    allowedRoutes:
      namespaces:
        from: Same
    tls: # [!code callout]
      mode: Terminate
      certificateRefs:
        - name: demo-tls
  - name: tcp
    port: 8080
    protocol: TCP
    allowedRoutes:
      namespaces:
        from: Same
  - name: udp
    port: 8080
    protocol: UDP
    allowedRoutes:
      namespaces:
        from: Same
---
apiVersion: gateway.envoyproxy.io/v1alpha1
kind: EnvoyProxy
metadata:
  name: demo   # [!code callout]
  namespace: demo
spec:
  provider:
    kubernetes:
      envoyService:
        type: ClusterIP  # [!code callout]
      envoyDeployment:
        replicas: 1
        container:
          imageRepository: registry.alauda.cn:60080/acp/envoyproxy/envoy  # [!code callout]
          resources: # [!code callout]
            limits:
              cpu: "1"
              memory: 1Gi
            requests:
              cpu: "1"
              memory: 1Gi
    type: Kubernetes # [!code callout]
```
<Callouts>
  1. [companion envoyproxy](#companion_envoyproxy)
  2. Specify which `GatewayClass` it belongs to
  3. [listener](#listener)
  4. [listener hostname](#listener_hostname)
  5. [listener support kind](#listener_support_kind)
  6. [listener allow ns](#listener_allow_route_ns)
  7. [tls configuration](#listener_tls)
  8. name of [companion envoyproxy](#companion_envoyproxy)
  9. [service type](#service_type)
  10. please keep and do not modify the default value of [repository](#image_repository) 
  11. resource for `envoy-proxy instance`
  12. please keep and do not modify it
</Callouts>
## Introduction
### Service Type\{#service_type}
Service Type essentially configures how the gateway is exposed. There are three modes: LoadBalancer NodePort and ClusterIP. 

#### LoadBalancer (**Recommended**)
The advantage is ease of use, and high-availability load balancing capabilities.
To use LoadBalancer, the cluster must have LoadBalancer support, which can be enabled via [MetalLB](../functions/create_metallb.mdx)

#### NodePort \{#access_gateway_via_nodeport}
The advantage is that it doesn't require any external dependencies.  

However, disadvantages include:
- Can only be used in clusters with fewer than 16 nodes, otherwise the gateway status may become abnormal.
- When using NodePort, Kubernetes assigns NodePort port numbers that differ from the service's own ports. You must use the NodePort port number for access, not the service port.
- The service can be accessed via any node IP address in the cluster, which may pose potential security risks

##### How to Get The Correct Port When Using NodePort \{#get_nodeport_from_svc_port}

 ```bash
 kubectl get svc -n ${ENVOYGATEWAYCTL_NS} -l gateway.envoyproxy.io/owning-gateway-name=${GATEWAY_NAME} -o=jsonpath='{.items[0].spec.ports[?(@.port==${PORT})].nodePort}'
 ```
The output is the NodePort

#### ClusterIP
Very convenient if you don't need external exposure.

#### Listener \{#listener}
Listener defines the port and protocol for the gateway to listen on.
In HTTP or HTTPS protocols, different hostnames can be treated as a different listener.

You cannot create a listener with a conflicting port or protocol or hostname.

You must create at least one listener in the `Gateway`.

##### Listener Support Kind \{#listener_support_kind}
Each listener supports different route kinds based on its protocol:
| Listener Protocol | Supported Route Kind |
|-------------------|----------------------|
| HTTP              | HTTPRoute            |
| HTTPS             | HTTPRoute, GRPCRoute |
| TLS               | TLSRoute             |
| TCP               | TCPRoute             |
| UDP               | UDPRoute             |

When configuring routes, ensure they match the protocol of the listener they'll attach to. For example, you cannot attach an HTTPRoute to a TCP listener.


##### Allow Route NS \{#listener_allow_route_ns}
By default, Routes can only attach to a Gateway in the same namespace. To allow cross-namespace routing, you need to specify which namespaces are allowed to attach Routes to this Gateway's listener using the `allowedRoutes` field.

For more information, please reference [attach to gateway create on other ns](../how_to/tasks_for_envoy_gateway.mdx#attach_to_gateway_create_on_other_ns)

##### TLS \{#listener_tls}
By default, you can only use `secret` created in the same namespace. Otherwise, please refer to [use secret create on other ns](../how_to/tasks_for_envoy_gateway.mdx#use_secret_create_on_other_ns).

By default, we use `Terminate` mode. Otherwise please refer to [ssl paasthrough](../how_to/tasks_for_envoy_gateway#cert_referencegrant).


##### Hostname \{#listener_hostname}

The hostname in a listener is a unique identifier for listeners that have the same protocol. you cannot add or update a conflicting listener in a gateway.
##### Intersection Rule For Listener's Hostname And Route's Hostnames \{#intersection_rule}

When a request arrives, it is matched against the **intersection** of the Listener's hostname and the Route's hostnames. Only hostnames in the intersection are used for routing traffic.

| Listener Hostname | Route Hostnames | Intersection Result | Example |
|------------------|-----------------|---------------------|---------|
| No hostname | No hostnames | Matches all hosts | Any incoming host header is accepted |
| No hostname | Has hostnames (e.g., `api.example.com`) | All Route hostnames | Only requests with `api.example.com` are matched |
| Has hostname (e.g., `api.example.com`) | No hostnames | All Listener hostnames | Only requests with `api.example.com` are matched |
| Has hostname (e.g., `api.example.com`) | Has matching exact hostname (e.g., `api.example.com`) | Exact match hostname | Only requests with `api.example.com` are matched |
| Has wildcard (e.g., `*.example.com`) | Has matching hostnames (e.g., `api.example.com`, `web.example.com`) | Matching specific hostnames | Requests with `api.example.com` or `web.example.com` are matched |
| Has hostname (e.g., `api.example.com`) | Has non-matching hostnames (e.g., `web.example.com`) | **No intersection** - Route status is abnormal | Route cannot process traffic |

:::note
Wildcards (`*`) perform suffix matching. For example, `*.example.com` matches `foo.example.com` and `bar.example.com`, but not `example.com`.
:::
:::warning
No intersection - Route status is abnormal, and cannot process traffic.
:::

### Companion EnvoyProxy \{#companion_envoyproxy}
`Envoy Gateway` provides different granularities for controlling gateway deployments. We recommend creating a dedicated `EnvoyProxy` resource for each Gateway and referencing it through the Gateway's `.spec.infrastructure.parametersRef` field. 

This one-to-one mapping approach provides better isolation and more granular control over deployment configurations such as replicas, resources, and scheduling constraints.

For other deployment configuration methods, please refer to [deployment-mode](https://gateway.envoyproxy.io/docs/tasks/operations/deployment-mode/).

### Image Repository \{#image_repository}
This is the default value. It will be replaced by the actual image repository of the current cluster, please do not modify it.
## Next Steps
[Configure route](../functions/configure_gatewayapi_route.mdx)

## Related Tasks
- [use secret create on other ns](../how_to/tasks_for_envoy_gateway.mdx#use_secret_create_on_other_ns)
- [attach to gateway create on other ns](../how_to/tasks_for_envoy_gateway.mdx#attach_to_gateway_create_on_other_ns)
- [ssl paasthrough](../how_to/tasks_for_envoy_gateway#cert_referencegrant)