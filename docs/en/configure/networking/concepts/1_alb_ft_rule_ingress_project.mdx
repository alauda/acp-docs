---
weight: 1
---
# relationship between ALB, ALB-Instance, Frontend/FT, Rule, Ingress, and Project
loadBalancer is a key component in modern cloud-native architectures, serving as an intelligent traffic router and load balancer. 

to understand how ALB works in a kubernetes cluster, we need to understand several core concepts and their relationships
- ALB itself
- Frontend (ft)
- Rules
- Ingress resources
- projects

these components work together to enable flexible and powerful traffic management capabilities.

this article mainly introduces how these concepts work together and what roles they play in the request-calling chain. Detailed introductions for each concept will be covered in other articles.


```mermaid
graph LR
    Client[client] -->|network-request| ALB[alb-instance]
    
    subgraph "Kubernetes cluster"
        subgraph "Svc-A"
            SvcAPod1
            SvcAPod2
        end
    ALB -->|route to pod via ingress| SvcAPod1
    end
```

in a request-calling chain.
1. a client send an http/https/other protocol request, and finally the request will **arrive on a pod of alb**, and the pod(a alb-instance) will start to handle this request.
2. this alb-instance finds a rule  which could match this request.
3. if needed, modify/redirect/rewrite the request based on the rule.
4. find and select one pod ip from the services which the rule configured. And forward the request to the pod.

## ingress
ingress is a resource in kubernetes, used to describe what request should be send to which service.
## ingress controller
a program that understand ingress resource and will proxy request to service.
## alb
is a ingress controller.

in kubernetes cluster, we use the `alb2` resource to operator a alb. you could use `kubectl get alb2 -A` to view all the alb in the cluster.

alb are created by user manually. and each alb has its own ingressClass, when you create an ingress, you can use `.spec.ingressClassName` field to indicate which ingress controller should handle this ingress.

## alb instance
alb also is a deployment(bunch of pod) running in the cluster. each pod is called as a alb instance.

each ALB instance handles requests independently, but all instances share frontend (ft), rule, and other configurations belonging to the same ALB.


## alb-operator
alb-operator a default component deployed in the cluster is an operator for ALB. it will create/update/delete deployment and other related resource for each alb according to the alb resource.

## frontend (abbreviation: ft)
ft is a resource defined by alb itself. it is used to represent the alb instance listening ports.

ft could be created by alb-leader or user manually.

case of ft created by alb-leader:
 1. if ingress has has certificate we will create ft 443 (https)
 2. if ingress has no certificate we will create ft 80 (http).

## RULE
RULE is a resource defined by alb itself. 
it take the same role as the ingress, but it is more specific.
a RULE is uniquely associated with a ft.

RULE could be created by alb-leader or user manually.

case of RULE created by alb-leader:
1. sync ingress to RULE.

## alb leader
in  multiple alb-instance, it will elect one as leader.
the leader is responsible for
1. translating the ingress into rules.
    we will create rule for each path in the ingress.
2. create ft need by ingress.
    for example, if ingress has has certificate we will create ft 443 (https), if ingress has no certificate we will create ft 80 (http).

## project
from the perspective of alb, project is a set of ns.

you could configure one or more project in a alb. 
when alb leader translate the ingress into rules, it will ignore ingress in ns which not belongs to the project.

