---
weight: 30
i18n:
  title:
    en: Creating applications from Image
    zh: 通过镜像创建应用
title: Creating applications from Image
---

# Creating applications from Image

## Prerequisites

Obtain the image address. The source of the images can be from the image repository integrated by the platform administrator through the toolchain or from third-party platforms' image repositories.

- For the former, the Administrator typically assigns the image repository to your project, and you can use the images within it. If the required image repository is not found, please contact the Administrator for allocation.

- If it is a third-party platform's image repository, ensure that images can be pulled directly from it in the current cluster.

## Procedure

1. **Container Platform**, navigate to **Applications** > **Applications** in the left sidebar. 

2. Click **Create**.

3. Choose **Create from Image** as the creation approach.  

4. **Select** or **Input** an image, and click **Confirm**.

:::info
   **Note**: When using images from the image repository integrated into web console, you can filter images by **Already Integrated**. The **Integration Project Name**, for example, images (docker-registry-projectname), which includes the project name projectname in this web console and the project name containers in the image repository.
:::

6. Refer to the following instructions to configure the related parameters.

| **Related parameters** | **Description** |
|:--------------------------|:--------------------------|
| **Workload**| Select a workload as needed: <ul><li>**Deployment**: For detailed parameter descriptions, please refer to [Creating Deployment](../application_workloads/deployment_create.mdx).</li><li>**DaemonSet**: For detailed parameter descriptions, please refer to [Creating DaemonSet](../application_workloads/deamonset_create.mdx).</li><li>**StatefulSet**: For detailed parameter descriptions, please refer to [Creating StatefulSet](../application_workloads/statefulset_create.mdx).</li></ul>  |
| **Service** | Kubernetes **Service**, expose an application running in your cluster behind a single outward-facing endpoint, even when the workload is split across multiple backends.. For specific parameter explanations, please refer to [Creating Services](/developer/building_application/functions/operation_after_creating/network_communications/service/create_service.mdx).<br/><br/>**Note** The default name prefix for the internal routing created under the application is the name of the compute component. If the compute component type (deployment mode) is StatefulSet, it is advisable not to change the default name of the internal routing (the name of the workload); otherwise, it may lead to accessibility issues for the workload. |
| **Ingress** | Kubernetes **Ingress**, make your HTTP (or HTTPS) network service available using a protocol-aware configuration mechanism, that understands web concepts like URIs, hostnames, paths, and more. The Ingress concept lets you map traffic to different backends based on rules you define via the Kubernetes API. For detailed parameter descriptions, please refer to [Creating Ingresses](/developer/building_application/functions/operation_after_creating/network_communications/ingress/create_ingress.mdx).<br/><br />**Note**: The **Service** used when creating **Ingress** under the application must be resources created under the current application. However, ensure that the **Service** is associated with the workload under the application; otherwise, service discovery and access for workload will fail. |

7. Click **Create**.

## Application Management Operations

To modify application configurations, use one of the following methods:  
1. Click the vertical ellipsis (⋮) on the right side of the application list.  
2. Select **Actions** from the upper-right corner of the application details page.


| **Operation** | **Description** |
|:--------------------------|:--------------------------|
| **Update** | <ul><li>**Update**: Modifies only the target workload using its defined [update strategy](../application_workloads/deployment_create.mdx#updatepolicy) (Deployment strategy shown as example). Preserves existing replica count and rollout configuration. </li><li>**Force Update**: Triggers full application rollout using each component's update strategy. <br/>1. **Use cases**: <ul><li>Batch configuration changes requiring immediate cluster-wide propagation (e.g., ConfigMap/Secret updates referenced as environment variables). </li><li>Coordinated component restarts for critical security. </li></ul> 2. **Warning Caution**: <ul><li>May cause temporary service degradation during mass restarts. </li><li>Not recommended for production environments without business continuity validation.</li></ul></li><li>**Network Implications**: <ul><li>Ingress Rule Deletion: External access remains available via `LB_IP:NodePort` if: <br/> 1) LoadBalancer Service uses default ports. <br/> 2) Surviving routing rules reference application components. <br/>Full external access termination requires Service deletion.</li><li>Service Deletion: Irreversible loss of network connectivity to application components. Associated Ingress rules become non-functional despite API object persistence.</li></ul></li></ul> |
| **Delete** | <ul><li>**Cascading Deletion**: <br/> 1. Removes all child resources including Deployments, Services, and Ingress rules. <br/> 2. Persistent Volume Claims (PVCs) follow retention policy defined in StorageClass</li><li>**Pre-deletion Checklist**: <br/> 1. Verify no active traffic through associated Services. <br/> 2. Confirm data backup completion for stateful components. <br/> 3. Check dependent resource relationships using `kubectl describe ownerReferences`.</li></ul>|
