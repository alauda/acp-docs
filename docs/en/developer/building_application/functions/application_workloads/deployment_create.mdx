---
weight: 10
sourceSHA: 8958e45cebd081946fcf6a514b5de3bd4c40b2262e3cf51086e81316acd88da6
---

# Creating a Deployment

A Deployment is a type of workload controller in Kubernetes that allows you to run a program by creating one. You can also create multiple Deployments within an application as workloads to provide specific services for stateless applications.

## Prerequisites

### Obtain an Image

Image sources include image repositories integrated into the toolchain by platform administrators, or third-party platform image repositories.

- For the former, platform administrators typically assign an image repository to your project, and you can use images from that repository. If it’s a third-party platform image repository, ensure that the images can be pulled from it in the current cluster.

- If the image being pulled requires credentials, you need to create the credentials (secret dictionary) in the current namespace beforehand.

## Step 1 - Configure Basic Information\{#updatepolicy}

1. Access the **Container Platform**.

2. In the left navigation bar, click **Compute Components** > **Deployments**.

3. Click **Create Deployment**.

4. Configure the image and click **Confirm**.

   **Note**: You can filter images using the **Select** option only when using images from the integrated image repository of this platform. For instance, the integrated project name such as *containers (docker-registry-projectname)* includes the project name *projectname* in this platform, as well as the project name *containers* in the image repository.

5. In the **Basic Information** section, refer to the following instructions to configure the relevant information.

   | Parameter                   | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
   | --------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
   | **Number of Instances**       | The expected number of Pods to run in the Deployment, defaulting to 1. Please modify as needed.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
   | **More > Update Policy** | Maximum number of Pods that can be temporarily extra and maximum number of Pods that cannot be available during a rolling update (rollingUpdate) of the Deployment. When rolling out updates, Pods are automatically added or removed for quick updates. <br /> **Note**: If not set, the default values for both maximum extra Pods and maximum unavailable Pods are 1. Supports entering instance count or percentage. <br />**Maximum extra Pods**: The maximum number of Pods for the calculating component that can be exceeded during a rolling update. If a percentage is entered, Kubernetes calculates it based on the current instance count and rounds up in case of a fraction. For example, 4.1 will round up to 5. <br />**Maximum unavailable Pods**: The maximum number of Pods that can be unavailable during a rolling update for the calculating component. The percentage cannot exceed 100%. If a percentage is entered, Kubernetes calculates it based on the current instance count and rounds down in case of a fraction. For example, 4.9 will round down to 4. <br /> Pods that are not running are counted as unavailable. <br />**Example**: When the number of Pods is 10, if the maximum extra Pods value is set to 2, and the maximum unavailable Pods value is set to 3, the total available Pods during the update process of the old and new versions will not exceed 10 + 2, and will not be less than 10 - 3. <br /> **Note**: Both the maximum extra Pods value and maximum unavailable Pods value cannot be 0 or 0% simultaneously. <br /> When entering percentage values, if the maximum extra Pods value rounds up to 0 and the maximum unavailable Pods value rounds down to 0, Kubernetes will adjust the maximum unavailable Pods value to round up to 1. |

## Step 2 - Configure Container Group

**Note**: When a mixed architecture cluster needs to deploy single-architecture images, ensure to add the correct [scheduling configuration](#schuconf) for the container group.

1. In the **Container Group** area, refer to the following instructions to configure the relevant information.

   | Parameter           | Description                                                                                                                                                                |
   | ------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
   | **Storage Volumes\{#4}** | Add specific types of storage volumes to mount in the container. For information on volume types, refer to [Storage Volume Mounting Instructions](#pvmount).                                          |
   | **Image Credentials** | Credentials must be selected only when the image address is entered via the **Input** method, i.e., when pulling images from a third-party platform image repository. <br /> **Note**: If images from the integrated image repository of this platform are used, the required credentials are automatically bound in the background.            |
   | **Termination Grace Period** | The maximum wait time allowed from receiving the Pod deletion request to the Pod being officially deleted, defaulting to 30 seconds. Set this parameter to allow the Pod to finish processing requests before stopping, gracefully taking the application offline or notifying other applications. <br /> If set to 0 seconds, the Pod will be forcibly deleted immediately, regardless of whether it is processing requests or executing commands. |

2. Scheduling Configuration\{#schuconf}

   | Parameter          | Description                                                                                                                                                                                                                                                                                                                                                                                                               |
   | ------------------ | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
   | **Node Selector**        | Schedules the container group to run on a suitable node. For example, if there are both Linux and Windows nodes in the cluster, to avoid scheduling Linux applications on Windows nodes, refer to the following example to select nodes. <br /><img src="./assets/nodeselector_os.png" width="500" />                                                                                  |
   | **Affinity**       | Schedules new Pods to nodes that meet affinity requirements based on the labels of existing target Pods on the node. Target Pods are Pods belonging to other compute components in the current namespace. <ul><li>Affinity: The new Pod and the specified Pod run on the same host.</li><li>Anti-affinity: The new Pod and the specified Pod do not run on the same host.</li></ul><br /><br />**Advanced** methods can implement more complex affinity scheduling requirements: <ul><li>**Required**: The new Pod will only be scheduled on nodes that fully meet the affinity requirements.</li><li>**Preferred**: The new Pod will be as much as possible scheduled on nodes that meet the affinity requirements. The system combines affinity weights with other scheduling needs (such as compute resource requirements) to determine the nodes on which the Pod can run.</li></ul><br />**Node Topology Domain**: Used to determine the node on which the target Pod can be scheduled. The node label should be specified here, defaulting to `kubernetes.io/hostname`. <br />**Match Labels**: Used to filter target Pods for affinity or anti-affinity with the new Pod, the labels of the target Pods should be specified here. |

3. Network Configuration.

   | Parameter                  | Description                                                                                                                                                                                                                          |
   | -------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
   | **Bandwidth Limits (Kube-OVN)**   | Used to limit the maximum upstream/downstream network rate of the Pod's container for reasonable utilization of network resources. <br /><ul><li>**Upstream Bandwidth**: The rate at which the Pod's container uploads data.</li><li>**Downstream Bandwidth**: The rate at which the Pod's container downloads data.</li></ul>                                                                          |
   | **Subnet (Kube-OVN)**     | Automatically allocated by the system, based on the subnet bound to your namespace by the administrator, it automatically assigns an IP for use by the container group. <br /> You can also specify a subnet based on business needs; in this case, the container group can only use IP addresses within the specified subnet. |
   | **Fixed IP (Kube-OVN)**   | After binding a fixed IP address, the container group will retain the same IP address even if the container's state changes, such as during upgrades, rollbacks, or host switches. Otherwise, a random available IP address will be assigned from the subnet. <br /> **Note**: <br /><ul><li>Multiple container groups from different compute components can bind the same fixed IP address, but only one container group is allowed to use that IP address at a time; when container groups belonging to different compute components start, they will compete for the IP address.</li><li>If there are multiple instances (container groups) in the compute component, ensure that the number of **Fixed IPs** you enter is greater than or equal to the number of instances. For example, if you set the instance count to *3* but only entered one fixed IP, then only one instance can start normally.</li></ul> |
   | **Fixed IP (Calico)**     | Similar to Kube-OVN, after binding a fixed IP address, the container group will retain the same IP address even if the container's state changes. Otherwise, a random available IP address will be assigned. <br /> **Note**: <br /><ul><li>Each IP address can only be bound to a single container group from one compute component as a fixed IP address, and cannot be reused.</li><li>If there are multiple instances (container groups) in the compute component, ensure that the number of **Fixed IPs** you enter is greater than or equal to the number of instances. For example, if you set the instance count to *3* but only entered one fixed IP, then only one instance can start normally.</li></ul>                                         |

## Step 3 - Configure Containers

1. In the **Container** area, refer to the following instructions to configure the relevant information.

   | Parameter                | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
   | ------------------------ | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
   | **Resource Requests and Resource Limits** | Resource requests specify the minimum CPU capacity or memory amount required for the container to run; resource limits specify the maximum CPU capacity or memory usage allowed during the container's operation. For specific unit descriptions, refer to [Resource Unit Instructions](/developer/overview/unit.mdx). <ul><li>If the namespace does not enable oversubscription ratio:<br />-- If CPU or memory resource limits have been <b>set for the namespace</b>: When creating a Deployment, the resource requests or limits for the container have default values and support modification.<br />-- If no resource limits have been <b>set for the namespace</b>: There are no default values, and custom resource requests or resource limits can be set.</li><li>If the namespace enables oversubscription ratio:<br />User-defined resource limits automatically compute the resource requests based on the oversubscription ratio, and the resource requests cannot be modified. Here, resource requests equal the ratio of resource limits and the oversubscription ratio.<br /><br /></li></ul> <b>Note</b>:<ul><li>The resource request value must be less than or equal to the resource limit value, and the container's resource requests or limits cannot exceed the maximum value of the resource limits for the namespace.</li><li>Updating the oversubscription ratio will not immediately affect the running container group's resource requests; only after the container group is rebuilt will the resource requests be recalculated based on the latest oversubscription ratio.</li><li>When the namespace enables oversubscription, resource requests equal the ratio of resource limits and the oversubscription ratio, and custom resource request values are no longer effective.</li><li>When the namespace does not set resource quotas and limits, there will be no restrictions on container resource requests and limits when creating a Deployment.</li></ul> |
   | **Extended Resources**             | When there are available extended resources in the cluster, select and configure the extended resources.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
   | **Storage Volume Mounting**     | Configure storage information for persistent storage of container data. For information on volume types, refer to [Storage Volume Mounting Instructions](#pvmount). <ul><li>If storage volumes have already been added in the container group, click **Add**.</li><li>If no storage volumes have been added in the container group, click **Add Storage Volume and Mount**.</li></ul>Common parameter descriptions:<ul><li>**Mount Path**: The path for mounting the storage volume in the container file system.</li><li>**Subpath**: The relative path of an existing file that the container can use to store data. <br /> When the volume type is `ConfigMap` or `Secret`, you can choose a key from the configuration as a subpath. The mount path combined with the subpath forms the complete storage volume mount path, pointing to a specific folder or file name.</li><li>**Read-Only**: The access method for the storage volume. If enabled, the access method for the storage volume is read-only; if disabled, the access method is read-write.<br />For more information, refer to [Volumes](https://kubernetes.io/docs/concepts/storage/volumes/).</li></ul>                                                                                                                                                              |
   | **Ports**                  | Ports to be exposed from the container. The following example shows exposing TCP port *6379* on the container, naming it *redis*. <ul><li>**Protocol**: The protocol used by the container port, such as TCP.</li><li>**Port**: The container port exposed in the backend Pod, e.g., *6379*. If you selected an image from the registry, it will automatically fill in the exposed container port in the image's Dockerfile.</li><li>**Port Name**: It is recommended to use an easily recognizable name, such as *redis*.</li></ul>                                                                                                                                                                                                                                                                                                   |
   | **Startup Command and Arguments** | Example 1: Run the command *top -b* upon starting the container. <ul><li>In the **Startup Command** area, add *top -b*.</li><li>In the **Startup Command** area, add *top*, and in the **Arguments** area, add *-b*.</li></ul><br />Example 2: Predefine an environment variable *MESSAGE:Welcome!*, and upon starting the container, output *Welcome!*. <ul><li>In the **Startup Command** area, add */bin/sh -c "while true; do echo $(MESSAGE); sleep 10; done"*.</li><li>You can also refer to example one to set names and parameters separately.</li></ul><br />For more examples and explanations, refer to the [Official Documentation](https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container).                                                                                                                                                    |
   | **Environment Variables**               | <ul><li>Directly set the key and corresponding value of the environment variable.</li><li>Reference fields from objects like ConfigMap, Secret, fieldRef, resourceFieldRef, etc., as the value of environment variables.</li></ul><br />**Note**: Adding the same reference field via environment variables will override the relevant configurations from the configuration file or image.                                                                                                                                                       |
   | **Configuration References**           | Introduce configuration items as environment variables into the container by completely referencing a ConfigMap or Secret. Only **Opaque** and **Username/Password** types of secrets are supported for reference.                                                                                                                                                                                                                                                                                                          |
   | **Health Checks**              | **Liveness Health Check**: Checks whether the compute component is healthy; if the detection result is abnormal, it will decide whether to restart the instance based on the health check configuration. <br /> **Readiness Health Check**: Checks whether the compute component has completed startup and is in a normal service state; if the health state of the container instance is detected as abnormal, the container state will be updated. <br /> <br />For related parameter descriptions, refer to [Health Check Parameter Instructions](#healthcheck).                                                                                                                                                                                                                                       |
   | **Log Files**               | Used to configure the logs that you wish to collect from the container, including standard output `stdout` as well as log text files within the container. For example, `/var/log/*.log` means that apart from standard output, all text logs under `/var/log/` in the container will be collected. <br /><br />**Note**:<ul><li>This feature is supported by default when the container storage driver is overlay2; if the container storage driver is devicemapper, you must also manually mount the EmptyDir type storage volume to the directory where the log files are located.</li><li>If the logs are stored on Windows nodes in the cluster, also ensure that the log file path or its parent path has been mounted as a storage volume. For example, after mounting *c:/a*, you can set it to collect logs from `c:/a/b/c/*.log`.</li></ul>                                                                                                                                                                                                                                                                                          |
   | **Exclude Log Files** | Declare log files that do not need to be collected and saved within the range of logs to be collected. For example, `/var/log/aaa.log` indicates that all text logs under `/var/log/` in the container will be collected except for `aaa.log`.                                                                                                                                                                                                                                                                                                                              |
   | **Execute Before Stopping** | Also known as PreStop script; this will trigger the execution of the specified command before the container is deleted. For example, you can execute the command `echo "stop"` before stopping the container to verify whether the container logs are printed as expected before deletion. <br /> **Note**: If the container group's **Termination Grace Period** is less than the time required to execute the command here, the container will be forcibly deleted even if the command is not completed.                                                                                                                                                                                                                                                                                              |

2. Click **Add Container** in the upper right corner or <span style={{ display: 'inline-flex', alignItems: 'center', gap: '4px', verticalAlign: 'middle' }}><img src="./assets/expand.png" alt="expand" style={{ verticalAlign: 'middle' }} /> <span> > **Add Init Container**</span></span>.

   The description for init containers is as follows. For more information, refer to [Init Containers](https://kubernetes.io/docs/concepts/workloads/pods/init-containers/).

   - When the container group starts, init containers are prioritized for startup; only after all init containers are completed will the normal business containers start. When there are multiple init containers in the container group, they will start sequentially in the order they were added, and each init container must complete before the next one can start. Init containers will release CPU and memory resources after completing their task.

   - When there are more than 2 containers or at least 1 init container under the container group, deletion of containers/init containers is supported; deletion is not supported when there is only one business container.

3. Click **OK**.

## Reference Information ​

### Storage Volume Mounting Instructions\{#pvmount}

| Type                   | Purpose                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| ---------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Persistent Volume Claim** | Choose an existing [Persistent Volume Claim](/developer/building_application/functions/preparation_before_creating/add_pvc.mdx) to request a persistent volume as storage resources. <br />**Note**: Only Persistent Volume Claims bound to a persistent volume (PV) can be selected. If the Persistent Volume Claim is not bound to a PV, it will cause failure in creating the container group.                                                                                                                                                                                                         |
| **ConfigMap**          | Add the entire [ConfigMap](/developer/building_application/functions/preparation_before_creating/add_configmap.mdx) or part of its data to a storage volume and mount the storage volume to the container file system. This method facilitates [hot configuration updates](/developer/building_application/functions/operation_after_creating/hotreload.mdx), reducing the impact on business availability upon modifying configurations compared to referencing a ConfigMap via environment variables. <ol><li>After selecting the configuration file, the entire configuration file will be used as the storage path, and files will be generated under that path based on the keys in the configuration file; the key will be the name of the storage file, and the corresponding value will be the content.</li><li>You can also select a key from the ConfigMap as a subpath, e.g., `my.cnf`. If multiple keys from the ConfigMap need to be used as subpaths for mounting a storage volume, you can repeat the above steps.</li></ol> |
| **Secret**             | Mount the entire [Secret](/developer/building_application/functions/preparation_before_creating/add_secret.mdx) or some of its configuration items as a storage volume in the container file system. <br />The specific operations are as follows:<br /><ul><li>After selecting the secret, the entire secret file will be used as the storage path, and files will be generated under that path based on the keys in the secret file; the key will be the name of the storage file, and the corresponding value will be the content.</li><li>You can also select a key from the secret as a subpath. For example, `my.cnf`. If multiple keys from the secret need to be used as subpaths for mounting a storage volume, you can repeat this step.</li></ul>                                                                                                                   |
| **Generic Ephemeral Volume** | A volume processed by the cluster storage driver that has characteristics including not being limited to specific storage types or plugins, being dynamically created, expandable, and defined or used in a declarative manner; it also has relatively simple configuration. The lifecycle of the volume is tied to the Pod that defines it; it will be created before the Pod starts and deleted when the Pod is removed. This type of volume is suited for storing large amounts of temporary data or other information that does not require persistence. For specific parameter descriptions, refer to [Creating Persistent Volume Claims](/developer/building_application/functions/preparation_before_creating/add_pvc.mdx).                                                   |
| **Empty Directory**    | If you set the storage volume type of the container to **Empty Directory**, an empty directory will be created when the Pod is assigned to a host, and it will remain as long as the container runs on that host. If the container is deleted from the host, the empty directory will also be deleted, resulting in data loss. Empty directories are convenient for sharing files among containers running within the same Pod and allow individual containers to write temporary data to disk.                                                                                                                                                                              |
| **Host Path**          | Store container data to a path on the local file system of the host. The host path must start with `/`, for example: `/volumepath`.                                                                                                                                                                                                                                                                                                                  |

### Health Check Parameter Instructions\{#healthcheck}

| Parameter          | Description                                                                                                                                                            |
| ------------------ | --------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Startup Time**   | Enter the estimated seconds required for the compute component to start; health check failure results during this estimated startup time will be ignored until the first successful health check. The default value is `300`.        |
| **Interval**       | Enter the interval in seconds for each health check. Range: 1 ~ 120. The default value is `60`.                                                                       |
| **Timeout Duration**| Enter the timeout in seconds for waiting for the HTTP return value. Each timeout counts as a health check failure. Range: 1 ~ 300. The default setting is `30`.    |
| **Success Threshold**| Enter the minimum number of successful consecutive health checks. Health checks pass when this success threshold is reached. The default value is `0`.                        |
| **Failure Threshold**| Enter the maximum number of health check failures. When the input maximum is reached, the compute component will be restarted. When inputting `0`, health check failure counts will be ignored, and the container will not restart. The default value is `5`. |
| **Protocol**       | (HTTP protocol type) HTTP, HTTPS.                                                                                                                                    |
| **Port**           | (HTTP or TCP protocol type) Enter the container port number to be monitored.                                                                                         |
| **Path**           | (HTTP protocol type) Enter the protocol path to monitor the page. For example: `/login.html`.                                                                         |
| **Request Headers** | (HTTP protocol type) Click **Add**, enter one or more custom request header's name and value.                                                                        |
| **Startup Command** | (EXEC protocol type) Enter the monitoring command in the container. This can be executed via the docker exec command. Absolute paths can be used. If using command names or script names, test whether the program executes normally using the docker exec command. If quotes are included, they need to be escaped. |
