---
weight: 10
i18n:
  title:
    en: Introduction
    zh: 介绍
title: Introduction
---

# Introduction

The Developer view module empowers developers with cloud-native application orchestration and operational capabilities. It provides a unified interface for application composition from multiple sources while integrating built-in observability tools for production operations.

## Advantages

> The Developer view module delivers the following key advantages:

1. Unified Application Orchestration

    - Images: Deploy from public/private registries with image

    - YAML: Direct Kubernetes resource declarations with schema validation

    - Source to Image (S2I): Build containerized applications directly from source code

    - Helm Charts: Deploy packaged applications from curated Application Catalog

    - Implements GitOps-aligned application composition using multiple approaches

2. Holistic Lifecycle Management
    
  > Implements declarative management for workloads and namespaces:

    - Progressive Delivery: Canary/Blue-Green deployments via ServiceMesh

    - Resource Governance:

        - Namespace provisioning with RBAC policies

        - Resource allocation policies via HPA/VPA

        - Dynamic scaling with Cluster Autoscaler integration

    - Workflow Automation: CI/CD pipeline integration with Tekton

3. Enterprise-Grade Namespace Controls
    
  > Implements multi-tenant namespace management:
    
    - Complete lifecycle management

    - Resource Guarantees:

        - ResourceQuota and LimitRange configurations

        - Configurable overcommit ratios for CPU/Memory

4. Full-Stack Observability

  > Integrated monitoring stack with:
  
  - Event Correlation: Kubernetes Event and Audit log integration
  - Log Analytics: Log aggregation
  - Metrics dashboard: Monitoring and Custom alert rules

## Use Cases

> The main use cases of the Developer module include:

- Multi-Cloud Deployment

Organizations distribute workloads across multiple cloud providers (AWS, Azure, GCP) to avoid vendor lock-in, optimize costs, and ensure resilience. Cloud-native application delivery enables consistent deployment pipelines that abstract provider-specific implementations.

- Hybrid Cloud Environments

Enterprises maintain on-premises infrastructure alongside public cloud resources. Cloud-native delivery provides unified application deployment across hybrid environments while managing heterogeneous infrastructure complexities.

- Edge Computing Integration

As edge computing gains prominence, applications must run in centralized clouds, edge devices, and regional edge nodes. Cloud-native delivery extends deployment capabilities to these distributed edge environments.

- Development-to-Production Pipeline

Cloud-native methodologies enable seamless promotion of applications from development through testing/staging to production, preserving configuration consistency while accommodating environment-specific requirements.

- Global Multi-Region Deployments

For globally distributed applications, cloud-native delivery ensures consistent deployments across geographic regions, addressing latency optimization and data locality compliance.

- Disaster Recovery and Workloads Continuity

Cloud-native delivery facilitates disaster recovery environment provisioning that mirrors production systems, enabling rapid failover and ensuring uninterrupted operations.

## Cross-Cutting Cloud-Native Principles

> These scenarios leverage core cloud-native principles:  
- Containerization  
- Infrastructure-as-Code (IaC)  
- Declarative configurations  
- Immutable infrastructure  
- GitOps workflows  

These ensure consistency, reliability, and automation across heterogeneous computing environments.
