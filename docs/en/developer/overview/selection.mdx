---
weight: 40
sourceSHA: f77e2ece0be1dea87172c1a9e0cce1db3495d21769c1d840d955ce82501fd692
---

# Application and Workload Selection

## Application Selection

Currently, the platform offers five types of applications: OAM application, native application, template application, component application. Each type has its applicable scenarios. Additionally, the platform provides a GitOps management approach, which necessitates selecting applications based on real environments and different dimensions. The selection process is as follows:

1. If there is historical legacy (burden, community, open source), choose the currently used application type.

   - Burden: The project currently uses legacy technologies, decisions, or code.

   - Community: The current project is influenced by the culture and decision-making of the community or the early history of the project.

   - Open Source: There are some open-source historical legacies that have impacted the current state of the project.

2. If there is no historical legacy, selection can be made based on the following content. Among them, ❌ means not needed; ✅ means required or allowed; ⭐️ indicates the level of skill or cost requirement. The more stars, the higher the required skill or cost. You can select according to actual conditions.

   | Reference Dimension                   | Native Application | Template Application | OAM Application | Operator Application | GitOps Application |
   | ------------------------------------ | ------------------- | -------------------- | ---------------- | -------------------- | ------------------ |
   | Business Application Complexity       | Simple              | Complex              | Complex          | Complex              | -                  |
   | Requirement for Kubernetes Expertise  | ⭐️⭐️⭐️⭐️          | ⭐️⭐️                | ⭐️               | ⭐️                   | ⭐️⭐️⭐️⭐️          |
   | Development Cost                     | ⭐️                 | ⭐️⭐️                | ⭐️⭐️⭐️          | ⭐️⭐️⭐️⭐️            | -                  |
   | Operational Cost                     | ⭐️⭐️⭐️⭐️         | ⭐️⭐️⭐️             | ⭐️⭐️             | ⭐️                   | ⭐️⭐️⭐️⭐️⭐️       |
   | Need for Business Resilience         | ❌                 | ❌                   | ❌               | ❌                   | ✅                 |
   | Allowing Capabilities for Third-Party Clients | ❌        | ✅                   | ✅               | ✅                   | ❌                 |
   | Need for an Independent Platform Development Team   | ❌        | ✅                   | ✅               | ✅                   | ❌                 |

   **Reference Dimension Explanation**:

   - **Business Application Complexity**: The number of computing components in the application; the more components, the more complex it becomes.

   - **Requirement for Kubernetes Expertise**: The level of mastery of various concepts and technologies in Kubernetes.

   - **Need for Business Resilience**: The necessity to set up resilience for business to maintain operations during catastrophic events such as natural disasters, hardware failures, network failures, etc.

   - **Allowing Capabilities for Third-Party Clients**: Whether users are allowed to package their applications using Helm Chart or Operator and provide them to third-party clients.

## Workload Selection

The platform offers five types of workloads: Deployment, DaemonSet, StatefulSet, Job, and CronJob. Each workload has its suitable scenarios, necessitating the selection of appropriate workloads. However, in practical applications, it may be necessary to combine multiple workloads to build a complete application system. For example, a complete application may consist of:

- Deploying front-end and back-end services using Deployment
- Deploying a database using StatefulSet
- Deploying a log collection component using DaemonSet
- Executing scheduled backup tasks using CronJob

| Workload Type        | Features                                                                                     | Selection Recommendations                                |
| -------------------- | ------------------------------------------------------------------------------------------- | -------------------------------------------------------- |
| **Deployment**       | <ul><li>Supports horizontal scaling</li><li>Supports rolling updates and rollbacks</li><li>Pod names are random and will change upon restart</li><li>Suitable for scenarios with parallel request processing</li></ul> | If it’s a stateless application (e.g., Web services, API services, front-end applications, microservices), prioritize this type. |
| **DaemonSet**        | <ul><li>Runs one Pod on each node</li><li>Automatically deploys Pods on new nodes</li><li>Automatically cleans up Pods when nodes are removed</li><li>Supports deploying on specific nodes</li></ul> | Choose this type if you need to run on every node (e.g., log collection, monitoring collection, storage services, network plugins). |
| **StatefulSet**      | <ul><li>Pod names are fixed and ordered</li><li>Provides stable network identifiers</li><li>Supports persistent storage</li><li>Deploys and scales in order</li></ul>         | Choose this type if your application requires fixed network identifiers or persistent storage (e.g., databases, distributed caches, message queues, search engines). |
| **Job**              | <ul><li>Ensures task completion</li><li>Supports running multiple Pods in parallel</li><li>Automatically cleans up after tasks are completed</li><li>Can set retry limits</li></ul>           | Choose this type for one-time tasks (e.g., data migration, file processing, batch calculations, sending emails). |
| **CronJob**          | <ul><li>Schedules Job runs based on time</li><li>Supports Cron expressions</li><li>Can configure task history retention policies</li><li>Can pause and resume scheduling</li></ul>      | Choose this type for periodically executed tasks (e.g., data backups, report generation, cleanup tasks, timed notifications). |
